---
title: "Analyse de sensibilité"
author: "Lucien Ricome & Abdourahmane Diallo"
date: "2023-09-11"

output: 
  html_document: 
    toc: yes
    toc_float: yes
    code_fold: hide
    warning: no
    message: no
    number_sections: yes
    
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```


```{r packages}
library(ggplot2) 
source("functionModProjet2023.r")
library(dplyr)
library(tidyr)
library(knitr) ; library(kableExtra)
library(reactable)
library(sensitivity)
```



# Description du modèle

## Type de modèle

Ce modèle est deterministe parce qu'il est défini par des équations deterministes ne comportant aucun terme tiré aléatoirement. Il est basé sur un pas de temps discret et est un modèle à compartiments.

## Processus biologique

Le modèle simule la propagation d'une maladie dans une population en fonction de divers processus biologiques, tels que la transmission de la maladie, les taux de guérison, les taux de mortalité, les taux de naissance, etc. …….

## Equations associées **a verifier a la fin**

\begin{align}

Première classe d'âge : FAIRE LES REFERENCES

\begin{cases}
A_{S,t+1} = A_{S,t}\times(1-m_1-t-trans\times \frac{N_{I,t}}{N}) + loss \times A_{R,t} + max(0 , sr \times portée \times \sum_{i=1}^{4} B_{i, t} \times f_2 + \sum_{i=1}^{4} C_{i, t} \times f_3 \times (1- \frac{N}{K})) \\
A_{E,t+1} = A_{E,t}\times(1-m_1-t-lat) + trans \times A_{1,t} \times  A_{S,t} \times \frac{N_I}{N} \\
A_{I,t+1} = A_{I,t}\times(1-m_1-t-madd - rec) + lat \times A_{E,t} \\
A_{R,t+1} = A_{R,t}\times(1-m_1-t-loss) + rec \times A_{I,t} \\

\end{cases}

Deuxième classe d'âge : 

\begin{cases}

B_{S,t+1} = A_{S,t}\times t_1 + B_{S,t} \times (1-m_2 - t_2 - trans \times \frac{N_{I,t}}{N_t})+ loss \times B_{R,t} \\
B_{E,t+1} = A_{E,t}\times t_1 + B_{E,t} \times (1-m_2 - t_2 - lat) + trans \times B_{S,t} \times \frac {N_{I,t}}{N_t} \\
B_{I,t+1} = = A_{I,t}\times t_1 + B_{I,t} \times (1-m_2 - t_2 - madd - rec) + lat \times B_{2,t} \\
B_{R,t+1} = A_{R,t}\times t_1 + B_{R,t} \times (1-m_2 - t_2 - loss) + rec \times B_{3,t} \\

\end{cases}

Troisième classe d'âge : 
 
\begin{cases}

C_{S,t+1} = B_{S,t}\times t_2 + C_{S,t} \times (1-m_3 - trans \times \frac{N_{I,t}}{N_t}) + loss \times C_{R,t} \\
C_{E,t+1} = B_{E,t}\times t_2 + C_{E,t} \times (1-m_3 - lat) + trans \times C_{S,t} \times \frac {N_{I,t}}{N_t} \\
C_{I,t+1} = = B_{I,t}\times t_2 + C_{I,t} \times (1-m_3 -  madd - rec) + lat \times C_{2,t} \\
C_{R,t+1} = B_{R,t}\times t_2 + C_{R,t} \times (1-m_3 - t_2 - loss) + rec \times B_{3,t} \\

\end{cases}


## Schéma des transitions

![Schéma des transitions](Schéma des transitions.png "Schéma des transitions du modèle") 
![Fécondité](Fecondite.png "Schéma des transitions du modèle")

## Hypothèses principales
- Transmission directe
- Population en trois classes d'âge
- Quatres étast liés à la maladie : 1) susceptible, 2) latent, 3) infectieux et 4) retiré
- Ce sont uniquement les individus infectés qui peuvent transmettre la maladie;
- Les individus peuvent perdre leur immunité
- Transmission de la maladie par fréquence dépendante


## Conditions initiales
Au début de la simulation, il y avait un nombre spécifique d'individus dans chaque classe d'âge et état de santé:
- il y avait 27 individus dans la première classe d'âge et dans l'état de santé Susceptible
- il y avait 23 individus dans la deuxième classe d'âge et dans l'état de santé Susceptible
- il y avait 36 individus dans la troisième classe d'âge et dans l'état de santé Susceptible
- il y avait 1 individus dans la troisième classe d'âge et dans l'état de santé Infectieux


## Sorties possibles du modèle ***A CONFIRMER ***
Les sorties du modèle sont enregistrées dans la matrice sortie à la fin de chaque scénario de simulation. Les sorties possibles sont:
- Sortie 1=  pourcentage de la population dans les états de santé latente et infectieux par rapport à la population totale,
- Sortie 2= Résultat de la fonction de transmission à la fin des deux années
- Sortie 3 = maximum du nombre d'individu infectieux dans l'état infectieux au fil des deux ans.
- Sortie 4 = somme des fonction de transmission au cours de la première année de la simulation


## Parametres du modèle
- K = 100 : Capacité maximale de la population
- sr =  0.5 : Taux de survie des descendants
- m1 =  0.0014 : Taux de mortalité naturelle de la première classe d’âge
- m2 =  0.00029 : Taux de mortalité naturelle  de la deuxième classe d’âge
- m3 =  0.0019 : Taux de mortalité naturelle  de la troisième classe d’âge
- f2 = 0.0019 : Taux de fécondité de la deuxième classe d’âge
- f3 =  0.0082 : Taux de fécondité de la troisième classe d’âge
- portee =  5 : Nombre total de descendant par individu
- t1 = 1/365: Transition de classe de 1 à 2
- t2 := 1/365: Transition de la classe 2 à 3
- trans =  0.3 probabilité qu’un individu susceptible devient latent
- lat = 1/5 : taux de passage de l'état latente à l'état infectieux
- rec =  1/20 : probabilité qu’un individu infecté devient immunisé
- loss = 1/100 : Probabilité qu’un individu immunisé redevienne susceptible
- madd = 0.001 : Mortalité causé par la maladie


## Figures 
***Peut être convertir la sorti generale de la fonction sous forme de tableau : colnames(sorties[[1]])***

```{r Figures mod1}

# Initialisation des paramètres 

nom = c("K", "sr", "m1", "m2", "m3", "f2", "f3", "portee", "t1", "t2", "trans", "lat", "rec", "loss", "madd"
)

ValNominale = c(100, 0.5, 0.0014, 0.00029, 0.0019, 0.0019, 0.0082, 5, 1/365, 1/365, 0.3, 1/5, 1/20, 1/100, 0.001)

parametres = matrix(data = ValNominale, ncol = 15)
colnames(parametres) <- nom

# Exécution du modèle

sorties = modAppli_bis(parametre = parametres) 
predictions = sorties[[2]][[1]]

# Sorties du modèle

colnames(sorties[[1]]) <- c("Part des \n infectés et latente \n instant final", "fct de transmission\n instant final", "Max infectieux", "somme\nfonction de transmission" )

sorties[[1]] %>%
  kable(format = "html", booktab = TRUE, caption = "Sorties du modèle")

# Représentations graphiques des prédictions.

    # plot en base

temps = 365*2

titres = c("Classe 1",
          "Classe 2",
          "Classe 3",
          "Population totale")


par(mfrow = c(2,2))

for (i in 1:4) {
plot_initial(classe = i, 
             titre = titres[i])
}


```

## Interprétation des figures



# Analyse de sensibilité : OAT

L'analyse de sensibilité "One-at-a-Time" (OAT) est une méthode qui vise à évaluer l'influence des paramètres d'un modèle sur ses résultats de manière individuelle. Cette approche consiste à modifier un paramètre à la fois, tout en maintenant les autres paramètres à leurs valeurs nominales (*ValNominale*), afin de mesurer l'impact de chaque paramètre sur les sortie  du modèle (*modAppli*).

## Choix des variations des paramètres
Nous avons sélectionné 5 valeurs en dessous et au-dessus des valeurs nominales pour constituer les 10 valeurs pour chacune des 15 paramètres. Nous avons choisi un incrément (voir script ci-dessous) adapté à la grandeur de chaque paramètre.

## Script

```{r Analyse de sensibilité OAT}

# Saisie de la valeur des incréments par paramètre (dans l'ordre du vecteur "nom")

increment = c(1, 0.05, 0.0001, 0.00001, 0.0002, 0.0002,
  0.0003, 0.5, 0.0002, 0.0002, 0.03, 
  0.01, 0.0005, 0.0005, 0.0001
)

# Execution de la fonction "var_para" qui permet d'appliquer l'incrémentation à chaque paramètre.

all_parametres <- var_para(parametres = parametres, increment = increment)

# Execution fonction oat (source) et stockage des résultats.

data_E <-
  data.frame(P = character(0), E1 = numeric(0), E2 = numeric(0), E3 = numeric(0), E4 = numeric(0)
  ) # dataframe de stock vide

for (t in 1:15) {
  
  results <- oat(matrices = all_parametres, parametres = t)
  
  # Créez un dataframe avec les résultats pour le paramètre t
  data_elas <- data.frame(
    P = as.factor(rep(results$Parametres, 10)),
    E1 = as.numeric(results$Elasticite[, 1]),
    E2 = as.numeric(results$Elasticite[, 2]),
    E3 = as.numeric(results$Elasticite[, 3]),
    E4 = as.numeric(results$Elasticite[, 4])
  )
  
  # Ajoutez les résultats au dataframe principal
  data_E <- rbind(data_E, data_elas)
  
}


```


## Figures
Les figures ci-dessous illustent le comportement du modèle concernant les résultats de l'analyse de sansibilité OAT aevc l'indice d'Elasticité (sensibilité relative) pour chacune des quatres sorties du modèle (E1, E2, E3 et E4).
```{r}
# Représentations graphiques de l'élasticité pour chaque paramètre

# Utilisation de abs() à toutes les colonnes numeric 
data_E1 <- data_E %>%
  mutate_if(is.numeric, abs)

data_E2 <- data_E1 %>% 
  pivot_longer(cols = c("E1", "E2", "E3", "E4"), names_to = "sorties", values_to = "Elasticite") # pivot pour formater le jeu de données --> ggplot

data_E2$sorties <- as.factor(data_E2$sorties)

data_E2 %>%
  ggplot(aes(x = P, y = Elasticite))+
  geom_boxplot() +
  theme_classic()+
  facet_wrap(vars(sorties), ncol = 1)

```

## Interpretation et limites
Les paramètres "rec", "loss", "trans", et "lat" exercent une influence prépondérante sur la sortie 1 qui était le pourcentage de la population dans les états de santé latents et infectieux par rapport à la population totale. Pour la sortie 2 qui était le résultat de la fonction de transmission des deux années de suivi, ce sont les paramètres "K" et "loss" qui démontrent la plus grande influence. Quant au maximum de la population dans l'état infectieux au fil des deux ans, ce sont les paramètres "rec", "trans", "K", et "lat" qui se révèlent être les plus significatifs. Enfin, en ce qui concerne la sortie 4 qui était la somme des fonctions de transmission au cours de la première année de la simulation, ce sont les paramètres "K", "loss", et "trans" qui affichent la plus forte influence.


L'analyse de sensibilité basée sur One-at-a-Time (OAT) ne fournit des informations sur les influences que dans le voisinage des *valeurs nominales* appliquées. De plus, elle ne permet pas de mettre en évidence les *effets des interactions* entre les paramètres. Cette méthode d'analyse de sensibilité n'est pas particulièrement adaptée à notre *modèle non linéaire*, car l'OAT est une approche locale. Dans sa forme la plus simple, elle fournit des *dérivées partielles* du modèle par rapport aux paramètres d'entrée.


# Analyse de sensibilité : Moris
L'analyse de sensibilité de type Morris est une méthode qui sert à évaluer la sensibilité d'un modèle dont chaque entrée du modèle varie sur toute sa gamme de valeurs possibles.
 
```{r Analyse de sensibilité morris}

all_parametres <- var_para(parametres = parametres, increment = increment)
sorti_morris <- morris(
  model = modAppli,
  factors = nom, 
  r = 5,
  design = list(
    type = "oat",n=100,
    levels = 6,
    grid.jump = 3
  ),
  binf = all_parametres[1, ], 
  bsup = all_parametres[11, ] 
)
# Reccuper la sortie de Morris pour les graphique
mu <- apply(sorti_morris$ee, 3, function(M){
  apply(M, 2, mean)
})
mu.star <- apply(abs(sorti_morris$ee), 3, function(M){
  apply(M, 2, mean)
})
sigma <- apply(sorti_morris$ee, 3, function(M){
  apply(M, 2, sd)
})

mu.star= as.data.frame(mu.star)
sigma= as.data.frame(sigma)
row.names(sigma)


```

## Figures
L'analyse de sensibilité "Morris" révèle que la plupart des paramètres ont des effets négligeables, notamment sur la sortie 1. En revanche, pour les sorties 3 et 4, tous les paramètres présentent des effets non linéaires et/ou avec des interactions significatives. De plus, en ce qui concerne la sortie 2, seul le paramètre "loss" montre un effet non linéaire, tandis que tous les autres paramètres ont des effets négligeables.


*Legendes figures*
- entrées ayant des effets négligeables (en jaune),
- entrées ayant des effets linéaires et sans interaction (orange),
- entrées ayant des effets non linéaires et/ou avec interactions (bleu)

```{r, fig.height=6}

# zone de graphique en 2 colonnes et 2 lignes
par(mfrow=c(2,2))

# Sortie 1
plot(0.1, 0.1, type="n", ylim=c(0, 0.005), xlim=c(0, 0.06), xlab="mu.star", ylab="sigma")
polygon(x = c(0,0,100), y = c(0,100,0), col = "skyblue", border = NA)
polygon(x = c(0,0,0.1), y = c(0,100,0), col = "yellow", border = NA)
polygon(x = c(0.1,100,0.1), y = c(0,0.1,0.1), col = "orange", border = NA)
points(mu.star$ycol1, sigma$ycol1)
text(mu.star$ycol1, sigma$ycol1, labels = row.names(sigma), cex = 1.3, pos = 3)
title("Sortie 1")

# Sortie 2
plot(0.1, 0.1, type="n", ylim=c(0, 0.040), xlim=c(0, 0.30), xlab="mu.star", ylab="sigma")
polygon(x = c(0,0,100), y = c(0,100,0), col = "skyblue", border = NA)
polygon(x = c(0,0,0.1), y = c(0,100,0), col = "yellow", border = NA)
polygon(x = c(0.1,100,0.1), y = c(0,0.01,0.01), col = "orange", border = NA)
points(mu.star$ycol2, sigma$ycol2)
text(mu.star$ycol2, sigma$ycol2, labels = row.names(sigma), pos = 3, cex = 1.3)
title("Sortie 2")

# Sortie 3
plot(0.1, 0.1, type="n", ylim=c(0, 1.4), xlim=c(0, 12), xlab="mu.star", ylab="sigma")
polygon(x = c(0,0,100), y = c(0,100,0), col = "skyblue", border = NA)
polygon(x = c(0,0,0.1), y = c(0,100,0), col = "yellow", border = NA)
polygon(x = c(0.1,900,0.1), y = c(0,0,0.1), col = "orange", border = NA)
points(mu.star$ycol3, sigma$ycol3)
text(mu.star$ycol3, sigma$ycol3, labels = row.names(sigma), pos = 3, cex = 1.3)
title("Sortie 3")

# Sortie 4
plot(0.1, 0.1, type="n", ylim=c(0, 12), xlim=c(0, 90), xlab="mu.star", ylab="sigma")
polygon(x = c(0,0,200), y = c(0,100,0), col = "skyblue", border = NA)
polygon(x = c(0,0,0.1), y = c(0,5000,0), col = "yellow", border = NA)
polygon(x = c(0.1,5000,0.1), y = c(0,0,0.1), col = "orange", border = NA)
points(mu.star$ycol4, sigma$ycol4)
text(mu.star$ycol4, sigma$ycol4, labels = row.names(sigma), pos = 3, cex = 1.3)
title("Sortie 4")


```


## Comparaison entre OAT et Moris

En comparant les deux approches, on constate que l'approche OAT se concentre sur des résultats spécifiques, tandis que la méthode Morris offre une perspective plus globale sur les effets des paramètres. Néanmoins, on retrouve des conclusions similaires concernant les paramètres les plus influents, qui sont principalement "loss", "trans", "portée" et "K".












